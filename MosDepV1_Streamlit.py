#!/usr/bin/env python
# coding: utf-8

# Дэшборд с результатами анализа подготовлен и размещен в Streamlit:
# https://yandexmaster-bxajbknwwrn5gqtuy8gqhw.streamlit.app/

# <h1>Содержание<span class="tocSkip"></span></h1>
# <div class="toc"><ul class="toc-item"><li><span><a href="#Цель,-задачи,-описание-источников-данных-и-план-исследования" data-toc-modified-id="Цель,-задачи,-описание-источников-данных-и-план-исследования-1"><span class="toc-item-num">1&nbsp;&nbsp;</span>Цель, задачи, описание источников данных и план исследования</a></span><ul class="toc-item"><li><span><a href="#Цель-работы:" data-toc-modified-id="Цель-работы:-1.1"><span class="toc-item-num">1.1&nbsp;&nbsp;</span>Цель работы:</a></span></li><li><span><a href="#Описание-источников-данных" data-toc-modified-id="Описание-источников-данных-1.2"><span class="toc-item-num">1.2&nbsp;&nbsp;</span>Описание источников данных</a></span></li><li><span><a href="#План-исследования" data-toc-modified-id="План-исследования-1.3"><span class="toc-item-num">1.3&nbsp;&nbsp;</span>План исследования</a></span></li><li><span><a href="#Первичное-исследование,-предобработка-и-дообогащение-данных:" data-toc-modified-id="Первичное-исследование,-предобработка-и-дообогащение-данных:-1.4"><span class="toc-item-num">1.4&nbsp;&nbsp;</span>Первичное исследование, предобработка и дообогащение данных:</a></span></li><li><span><a href="#Исследовательский-анализ-данных" data-toc-modified-id="Исследовательский-анализ-данных-1.5"><span class="toc-item-num">1.5&nbsp;&nbsp;</span>Исследовательский анализ данных</a></span><ul class="toc-item"><li><span><a href="#Анализ--выявленных-объектов-самостроя-по-округам,-в-том-числе:" data-toc-modified-id="Анализ--выявленных-объектов-самостроя-по-округам,-в-том-числе:-1.5.1"><span class="toc-item-num">1.5.1&nbsp;&nbsp;</span>Анализ  выявленных объектов самостроя по округам, в том числе:</a></span></li><li><span><a href="#Анализ--количества-проверок,-в-том-числе:" data-toc-modified-id="Анализ--количества-проверок,-в-том-числе:-1.5.2"><span class="toc-item-num">1.5.2&nbsp;&nbsp;</span>Анализ  количества проверок, в том числе:</a></span></li><li><span><a href="#Выводы-и-рекомендации,-подготовка-дэшборда." data-toc-modified-id="Выводы-и-рекомендации,-подготовка-дэшборда.-1.5.3"><span class="toc-item-num">1.5.3&nbsp;&nbsp;</span>Выводы и рекомендации, подготовка дэшборда.</a></span></li></ul></li></ul></li><li><span><a href="#Загрузка-первичное-исследование,-предобработка-и-дообогащение-данных" data-toc-modified-id="Загрузка-первичное-исследование,-предобработка-и-дообогащение-данных-2"><span class="toc-item-num">2&nbsp;&nbsp;</span>Загрузка первичное исследование, предобработка и дообогащение данных</a></span><ul class="toc-item"><li><span><a href="#Загрузка-данных" data-toc-modified-id="Загрузка-данных-2.1"><span class="toc-item-num">2.1&nbsp;&nbsp;</span>Загрузка данных</a></span></li><li><span><a href="#Проверка-на-дубликаты-и-исправление-типов-данных" data-toc-modified-id="Проверка-на-дубликаты-и-исправление-типов-данных-2.2"><span class="toc-item-num">2.2&nbsp;&nbsp;</span>Проверка на дубликаты и исправление типов данных</a></span></li><li><span><a href="#Дообогащение-данных-координатами-объектов" data-toc-modified-id="Дообогащение-данных-координатами-объектов-2.3"><span class="toc-item-num">2.3&nbsp;&nbsp;</span>Дообогащение данных координатами объектов</a></span></li><li><span><a href="#Отбор-и-объединение-данных-в-один-датафрейм-со-всеми-необходимыми-для-анализа-признаками" data-toc-modified-id="Отбор-и-объединение-данных-в-один-датафрейм-со-всеми-необходимыми-для-анализа-признаками-2.4"><span class="toc-item-num">2.4&nbsp;&nbsp;</span>Отбор и объединение данных в один датафрейм со всеми необходимыми для анализа признаками</a></span></li><li><span><a href="#Вывод-по-загрузке-предобрадотке-данных:" data-toc-modified-id="Вывод-по-загрузке-предобрадотке-данных:-2.5"><span class="toc-item-num">2.5&nbsp;&nbsp;</span>Вывод по загрузке предобрадотке данных:</a></span></li></ul></li><li><span><a href="#Исследовательский-анализ" data-toc-modified-id="Исследовательский-анализ-3"><span class="toc-item-num">3&nbsp;&nbsp;</span>Исследовательский анализ</a></span><ul class="toc-item"><li><span><a href="#Анализ-общего-количества-выявленных-объектов-самостроя-по-округам" data-toc-modified-id="Анализ-общего-количества-выявленных-объектов-самостроя-по-округам-3.1"><span class="toc-item-num">3.1&nbsp;&nbsp;</span>Анализ общего количества выявленных объектов самостроя по округам</a></span><ul class="toc-item"><li><span><a href="#Количество-и-распределение-объектов-самостроя-по-округам-г.-Москвы" data-toc-modified-id="Количество-и-распределение-объектов-самостроя-по-округам-г.-Москвы-3.1.1"><span class="toc-item-num">3.1.1&nbsp;&nbsp;</span>Количество и распределение объектов самостроя по округам г. Москвы</a></span></li><li><span><a href="#Визуализация-объектов-самостроя-по-округам-на-карте--г.-Москвы" data-toc-modified-id="Визуализация-объектов-самостроя-по-округам-на-карте--г.-Москвы-3.1.2"><span class="toc-item-num">3.1.2&nbsp;&nbsp;</span>Визуализация объектов самостроя по округам на карте  г. Москвы</a></span></li><li><span><a href="#Анализ-типов-объектов-самостроя-в-разрезе-округов-г.-Москвы" data-toc-modified-id="Анализ-типов-объектов-самостроя-в-разрезе-округов-г.-Москвы-3.1.3"><span class="toc-item-num">3.1.3&nbsp;&nbsp;</span>Анализ типов объектов самостроя в разрезе округов г. Москвы</a></span></li><li><span><a href="#Анализ-общих-характеристик-типов-объектов-самостроя" data-toc-modified-id="Анализ-общих-характеристик-типов-объектов-самостроя-3.1.4"><span class="toc-item-num">3.1.4&nbsp;&nbsp;</span>Анализ общих характеристик типов объектов самостроя</a></span><ul class="toc-item"><li><span><a href="#Анализ-объектов-по-размеру-площади" data-toc-modified-id="Анализ-объектов-по-размеру-площади-3.1.4.1"><span class="toc-item-num">3.1.4.1&nbsp;&nbsp;</span>Анализ объектов по размеру площади</a></span></li></ul></li></ul></li><li><span><a href="#Анализ-количества-проверок-по-районам" data-toc-modified-id="Анализ-количества-проверок-по-районам-3.2"><span class="toc-item-num">3.2&nbsp;&nbsp;</span>Анализ количества проверок по районам</a></span><ul class="toc-item"><li><span><a href="#Анализ-количества-проверок-по-объектам" data-toc-modified-id="Анализ-количества-проверок-по-объектам-3.2.1"><span class="toc-item-num">3.2.1&nbsp;&nbsp;</span>Анализ количества проверок по объектам</a></span></li><li><span><a href="#Анализ-количества-проверок-и-выявленных-нарушений-в-месяц" data-toc-modified-id="Анализ-количества-проверок-и-выявленных-нарушений-в-месяц-3.2.2"><span class="toc-item-num">3.2.2&nbsp;&nbsp;</span>Анализ количества проверок и выявленных нарушений в месяц</a></span></li><li><span><a href="#Анализ-количества-проверок-по-районам-г.-Москвы" data-toc-modified-id="Анализ-количества-проверок-по-районам-г.-Москвы-3.2.3"><span class="toc-item-num">3.2.3&nbsp;&nbsp;</span>Анализ количества проверок по районам г. Москвы</a></span></li><li><span><a href="#Анализ-количества-выявленных-нарушений-по-районам-г.Москвы" data-toc-modified-id="Анализ-количества-выявленных-нарушений-по-районам-г.Москвы-3.2.4"><span class="toc-item-num">3.2.4&nbsp;&nbsp;</span>Анализ количества выявленных нарушений по районам г.Москвы</a></span></li><li><span><a href="#Анализ-количества-проверок-в-разрезе-источников-задач" data-toc-modified-id="Анализ-количества-проверок-в-разрезе-источников-задач-3.2.5"><span class="toc-item-num">3.2.5&nbsp;&nbsp;</span>Анализ количества проверок в разрезе источников задач</a></span></li><li><span><a href="#Анализ-количества-проверок-в-разрезе-их-типов" data-toc-modified-id="Анализ-количества-проверок-в-разрезе-их-типов-3.2.6"><span class="toc-item-num">3.2.6&nbsp;&nbsp;</span>Анализ количества проверок в разрезе их типов</a></span></li><li><span><a href="#Анализ-видов-нарушений,-выявленных-проверками" data-toc-modified-id="Анализ-видов-нарушений,-выявленных-проверками-3.2.7"><span class="toc-item-num">3.2.7&nbsp;&nbsp;</span>Анализ видов нарушений, выявленных проверками</a></span></li></ul></li><li><span><a href="#Итоговые-выводы-и-рекомендации" data-toc-modified-id="Итоговые-выводы-и-рекомендации-3.3"><span class="toc-item-num">3.3&nbsp;&nbsp;</span>Итоговые выводы и рекомендации</a></span><ul class="toc-item"><li><span><a href="#Результаты-анализа-данных" data-toc-modified-id="Результаты-анализа-данных-3.3.1"><span class="toc-item-num">3.3.1&nbsp;&nbsp;</span>Результаты анализа данных</a></span></li><li><span><a href="#Рекомендации--части-обеспечения-качества-и-непротиворечивости-данных" data-toc-modified-id="Рекомендации--части-обеспечения-качества-и-непротиворечивости-данных-3.3.2"><span class="toc-item-num">3.3.2&nbsp;&nbsp;</span>Рекомендации  части обеспечения качества и непротиворечивости данных</a></span></li></ul></li></ul></li></ul></div>

# # Проект "Анализ и визуализация результатов мониторинга земельных участков на территории города Москвы"

# ## Цель, задачи, описание источников данных и план исследования

# ### Цель работы:
# 
#     Подготовить анализ о проведенных выездных проверках с 01.2023 по 03.2024 г., направленных выявление незаконных строительных объектов, с визуализацией информации по объектам, количеству проведенных мероприятий и их результатах.
# 
# Задачи проекта:
# 
#     1.В рамках проекта необходимо подготовить и визуализировать следующую  информацию для заказчика в разрезе административных округов:
# 
#         ●	Оценить общее количество объектов.
#         ●	Предложить возможные способы классификации объектов.
#         ●	Выявить общие характеристики объектов.
#         ●	Локализацию объектов.
#         ●	Оценить количество и распределение проверок по объектам.
#         ●	Распределение нагрузки между проверками.
#         ●	Частота проведения проверок и количество выявленных нарушений.
#     
#     2. Определить районы, в которых чаще всего проводятся проверки и районы с повышенным количеством нарушений.
#     3. Подготовить дэшборд/презентацию, подготовить выводы и предложить рекомендации заказчику.
# 

# ### Описание источников данных

#     Источники данных:
# 
#     Комментарий заказчика к источникам данных: 
#             - Задача может быть связана с несколькими мероприятиями (значение поля «№ распоряжения/поручения» задачи содержится в значении поля «№ проверки» мероприятия).
#             - Мероприятие может быть связано с одним объектом (по полю ID объекта самостроя).
# 
# 
#     Файл-excel с информацией на трех листах о проведенных выездных проверках, структура и содержание которого:
#     
#     1. Таблица "Задачи" содержит следующую информацию об источнике задачи/поручения и имеет поля:
#         
#             - № п/п - порядковый номер;
#             - Id задачи - системный номер задачи;
#             - Источник задачи - основание для проведения контрольного мероприятия (вид документа или информационная система, из которой пришел запрос); 
#             - Округ - сокращенное наименование округа г.Москвы
#             - Район - наименование района г.Москвы
#             - Тематика - правоустанавливающий документ-основание для проведения контрольного мероприятия 819/829-ПП)
#             - Тип объекта - ЗУ/НФ
#             - № распоряжения/поручения - первичный ключ задачи для связи с таблицей "Мероприятия"
#     
#     2. Таблица "Мероприятия" содержит информацию о выполненных в рамках поручений, отраженных на листе "Задачи", контрольных мероприятий и их результатах:
#             - № п/п - порядковый номер;
#             - Идентификатор мероприятия - первичный ключ, системный номер мероприятия;
#             - № проверки - ссылочный ключ на таблицу "Задачи". Несколько мероприятий могут иметь один номер Задачи.
#             - Дата создания карточки - дата создания карточки мероприятия в системе;
#             - Вид мероприятия - выездное/функциональное мероприятие;
#             - Дата обновления карточки - дата внесения изменений в карточку по результатам проверки;
#             - Дата проверки/обсл - дата проверки;
#             - Дата акта - дата составления акта по результатам проверки;
#             - Продолжительность (час) - длительность проверки в часах;
#             - Время начала осмотра - время начала проверки;
#             - Время завершения осмотра - время завершения проверки;
#             - Верифицировано - да/нет;
#             - Состояние верификации - верифицировано/не верифицировано;
#             - Дата верификации - дата верификации;
#             - Тип проверки/обследования - мониторинг;
#             - Результат - краткое описание результата проверки (что выявлено/не выявлено);
#             - Наличие нарушения - да/нет;
#             - Статьи нарушений - ссылка на статью КОАП г. Москвы
#             - Наличие предостережения - да/нет;
#             - Машино-место - да/нет;
#             - Проверка/обсл. в отношении - ЮЛ/ИП/ФЛ;
#             - Фактическое использование - краткое описание, для чего используется выявленный объект;
#             - Обращение на портал «Наш город» - да/нет;
#             - Комплексное использование - да/нет; 
#             - Площадь факт. исп., кв.м. - фактически используемая площадь; 
#             - Отказ от ознакомления с актом - да/нет;
#             - Округ - сокращенное наименование округа г.Москвы;
#             - Район - наименование района г.Москвы;
#             - Тип объекта - земельный участок;
#             - Площадь объекта - площадь земельного участка;
#             - Право пользования - основание права пользования;
#             - Площадь пресечения - площадь пресечения.
#             - Ведется строительство - да/нет; 
#             - Пресечено строительство - да/нет;
#             - Строительство возобновлено - да/нет;
#             - Незавершенное строительство - да/нет; 
#             - Наличие признаков угроз - да/нет;
#             - Признаки угроз - - пустое поле;
#             - ID НТО - пустое поле;
#             - ID объекта самостроя - ссылочный ключ на таблицу "Объекты";
#             - Нарушение ОАТИ - да/нет;
# 
#     2. Таблица "Объекты" содержит информацию о выявленных в рамках проверок объектах самостроя:
#             - № п/п - порядковый номер;
#             - Идентификатор объекта - первичный ключ объекта;
#             - Название объекта - Название объекта;
#             - Дата создания карточки объекта - дата создания карточки объекта в системе; 
#             - Основание выявления/первого обследования - источник основания для проверки;
#             - Вид мероприятия - выездное/функциональное мероприятие/Осмотр ОНФ;
#             - Округ - сокращенное наименование округа г.Москвы
#             - Район - наименование района г.Москвы;
#             - Тип объекта - тип объекта самостроя (здание/строение/гараж и др)
#             - Площадь/длина самостроя - площадь/длина самостроя;
#             - Единицы измерения площади/длины - кв.м;
#             - Площадь объекта - площадь объекта;
#             - Приложение 819-ПП - Приложение 2/Приложение 3;
#             - Состояние - отражает стадию включения/исключения в перечень самостроя;
#             - Количество объектов - количество объектов, шт.
#             - Рассматривается в рамках - 819-ПП;
#             - Дата выявления - дата выявления;
#             - Стадия строительства (из последнего КИМ) - статус строительства объекта;
#             - Демонтирован - да/нет;
#             - Дата демонтажа - дата;
#             - Плановая дата демонтажа - плановая дата;
#             - Измененная дата демонтажа - измененная дата;
#             - Отложенный демонтаж - да/нет;
#             - Фактическое использование - краткое описание, для чего используется выявленный объект;
#             - Лицо, осуществившее демонтаж - ГБУ/Собственник;
#             - ЗПО - имеются/не имеются/нет данных;
#             - Разр. на стр.  - имеются/не имеются/нет данных;
#             - ЕГРП - имеются/не имеются/нет данных;
#             - ID первого КИМ - первичный ключ, системный номер первого проверочного мероприятия;
#             - № первого КИМ - номер первого проверочного мероприятия;
#             - Дата первого КИМ - дата первого проверочного мероприятия;
#             - Дата акта первого КИМ - дата первого акта проверочного мероприятия;
#             - Результат первого КИМ - результат первого акта проверочного мероприятия;
#             - Состояние верификации первого КИМ - верифицировано/в работе/отправлено на верификацию/просрочено;
#             - ID последнего КИМ - первичный ключ, системный номер последнего проверочного мероприятия;
#             - № последнего КИМ - номер последнего проверочного мероприятия;
#             - Дата последнего КИМ - дата последнего проверочного мероприятия;
#             - Дата акта последнего КИМ - дата последнего акта проверочного мероприятия;
#             - Результат последнего КИМ - результат последнего акта проверочного мероприятия;
#             - Состояние верификации последнего КИМ - верифицировано/в работе/отправлено на верификацию/просрочено;
#             

# ### План исследования

# ### Первичное исследование, предобработка и дообогащение данных:
# 
#      1.1 первичный анализ датафрейма, выявление нелогичных типов данных;
#      1.2 анализ пропусков в данных, объем, возможные причины и метод заполнения, если это возможно и необходимо для дальнейшего анализа;
#      1.3 анализ и исправление типов данных при необходимости;
#      1.4 анализ датафрейма на предмет наличия дубликатов;
#      1.5 дообогащение данных при необходимости, в том числе:
#          - геокоординатами объектов для визуализации;
#      1.6 Отбор и объединение данных в один датафрейм со всеми необходимыми для анализа признаками.

# ### Исследовательский анализ данных
# 
# ####  Анализ  выявленных объектов самостроя по округам, в том числе:
#             
#          1. Оценка общего количества выявленных объектов самостроя по округам;
#              1.1 Классификация объектов;
#              1.2 Анализ общих характеристик объектов;
#              1.3 Локализация объектов
# 
# ####  Анализ  количества проверок, в том числе:
#          1. распределение проверок по объектам в разрезе:
#                  - «Округов», 
#                  - «Источников задач» и 
#                  - «Видов мероприятий»,
#                  - результатов проверок.
#                 
#          2. Анализ частоты проведения проверок и количества выявленных нарушений.
# 
#          3. Анализ количества проверок по районам
#          4. Анализ количества нарушений по районам
#         
#  
# ####  Выводы и рекомендации, подготовка дэшборда. 
#   

# ## Загрузка первичное исследование, предобработка и дообогащение данных

# In[120]:


import pandas as pd
import numpy as np
import datetime as dt
from datetime import datetime
import seaborn as sns
import matplotlib.pyplot as plt
import plotly.graph_objects as go
import warnings
warnings.filterwarnings('ignore')
import json
import re
from shapely.geometry import Polygon
import streamlit as st
import plotly.express as px 
from plotly.subplots import make_subplots
from matplotlib.axes import Axes
from folium import Map, Choropleth
from folium import Map, Marker
from folium.plugins import MarkerCluster
import geopandas as gpd
import matplotlib.colors as mcolors
from streamlit_folium import folium_static
import requests
from io import BytesIO


# In[3]:


#функция для проверки дубликатов
import pandas as pd

def check_duplicates(df, exclude_columns=None):
    # колонки исключения
    if exclude_columns:
        cols_to_check = df.columns.difference(exclude_columns)
    else:
        cols_to_check = df.columns
    
    # Проверяем дубликаты на основе выбранных колонок
    duplicate_rows = df.duplicated(subset=cols_to_check, keep=False)
    
    if duplicate_rows.any():
        print("Есть дубликаты в данных.")
        return df[duplicate_rows]
    else:
        print("Дубликатов не найдено.")
        return None


# ### Загрузка данных

# In[157]:


# загрузим данные из файла excel

try:
    url = 'https://raw.githubusercontent.com/AVGorbulya/Yandex_Master/main/data.xlsx'
    response = requests.get(url)
    data = response.content
    all_sheets_dict = pd.read_excel(BytesIO(data), sheet_name=None, skiprows=1)
    for sheet_name, df in all_sheets_dict.items():
        print(f"Лист: {sheet_name}")

except:
    #    pass
    file_path = 'C:/Users/GAV/Desktop/Study/BA/PythonScripts/Pets/MoscDep/data.xlsx'
    all_sheets_dict = pd.read_excel(file_path, sheet_name=None, skiprows=1)
    for sheet_name, df in all_sheets_dict.items():
        print(f"Лист: {sheet_name}")  


# In[152]:


# сформируем датафреймы
tasks_df = all_sheets_dict['Задачи']
events_df = all_sheets_dict['Мероприятия']
objects_df = all_sheets_dict['Объекты']
print(tasks_df.info())
print()
print(events_df.info())
print()
print(objects_df.info())


# In[136]:


# загрузим файл с координатами полигонов районов Москвы в формат е exel
try:
    url = 'https://raw.githubusercontent.com/AVGorbulya/Yandex_Master/main/geo_mo_mod.xlsx'
    response = requests.get(url)
    data = response.content
    geo_mo_mod = pd.read_excel(BytesIO(data))
    geo_mo_mod.info() 
except:
    geo_mo_mod = pd.read_excel('C:/Users/GAV/Desktop/Study/BA/PythonScripts/Pets/MoscDep/geo_mo_mod.xlsx')
    geo_mo_mod.info()


# Вывод:
#     
#     1. Загружены данные с трех листов в три датафрейма.
#     2. В датафрейме tasks (Задачи) пропуски в колонках округ и район, которых быть не должно. Но эти пропуски не критичны, так как по этим же признакам нет пропусков в вдух других датафреймах. Будем использовать их. Типы данных корректны.
#     3. В датафрейме events (Мероприятия) критических пропусков не выявлено, в основном все заполнено, там где имеются пропуски видимо нет информации на момент формирования данных, либо признак не используется. Типы данных в колонке "№ проверки" не корректный, необходимо приветсти к int, для возможности дальнейшего слияния датафреймов.
#     4.  В датафрейме objects (Мероприятия) критических пропусков не выявлено. Типы данных корректны.
#     

# In[ ]:





# ### Проверка на дубликаты и исправление типов данных

# In[9]:


# для преобразования типа данных колонки № проверки нужно убрать постфиксы в номерах /1
events_df['№ проверки'] = events_df['№ проверки'].apply(lambda x: int(x.split('/')[0]))


# In[10]:


print(events_df['№ проверки'].dtype)


# In[11]:


# Вызов функции
print(check_duplicates(tasks_df, exclude_columns=['№ п/п', 'Id задачи']))
print()
print(check_duplicates(events_df, exclude_columns=['№ п/п', 'Идентификатор мероприятия']))
print()
print(check_duplicates(objects_df, exclude_columns=['№ п/п', 'Идентификатор объекта', 'Название объекта']))
print()


# Вывод:
#       Явных дубликатов не выявлено.      

# ### Дообогащение данных координатами объектов

#      1. Сначала рассчитаем координаты центра каждого района города
#      2. Добавим эти координаты каждому объекту

# In[12]:


# рассчитаем геокоординты центров районов
# Функция для расчета центра полигона с помощью функции Polygon из библиотеки Shapely

#Формируем список кортежей координат из каждой пары координат, входящей в список списков координат формата (geojson)
def parse_coordinates(coord_str):
    # Используем регулярное выражение для нахождения всех чисел в строке
    numbers = re.findall(r'[\d.]+', coord_str)
    # Преобразуем найденные строки в числа и группируем их попарно
    it = iter(map(float, numbers))
    return list(zip(it, it))

# Функция для преобразования строки координат в центроид
# Созданные parse_coordinates пары кортежей координат передаются в функцию Polygon из библиотеки Shapely 
# для создания полигона, после чего рассчитывается и возвращается центроид полигона.
def get_centroid(coords_str):
    # Разбор строки с координатами и создание полигона
    coords = parse_coordinates(coords_str)
    polygon = Polygon(coords)
    # Возвращаем координаты центроида полигона
    return polygon.centroid.x, polygon.centroid.y

# Применение функции 
geo_mo_mod_tot = geo_mo_mod.copy()
geo_mo_mod_tot[['lon', 'lat']] = geo_mo_mod['coordinates'].apply(lambda x: pd.Series(get_centroid(x)))

geo_mo_mod_tot.head()


# In[13]:


# сверим названия районов
# Получаем уникальные значения районов из обоих DataFrame
districts_objects = set(objects_df['Район'].unique())
districts_geo = set(geo_mo_mod_tot['city_district'].unique())

print("Названия районов присутствуют только в objects_df:", districts_objects - districts_geo)
print("Названия районов присутствуюттолько в geo_mo_mod_tot:", districts_geo - districts_objects)


# In[14]:


# добавим отсутствующие координаты в geo_mo_mod_tot

# Установим координаты для округа "Восточный" и Истринский
coordinates_vostochny = {'lon': 55.815367, 'lat': 37.868211}


# Добавляем координаты в DataFrame
geo_mo_mod_tot.loc[geo_mo_mod_tot['city_district'] == 'Восточный', 'lon'] = coordinates_vostochny['lon']
geo_mo_mod_tot.loc[geo_mo_mod_tot['city_district'] == 'Восточный', 'lat'] = coordinates_vostochny['lat']

coordinates_istra = {'lon': 55.934623, 'lat': 36.762655}

# Проверяем, существует ли уже строка с 'Истринский'
if not geo_mo_mod_tot[geo_mo_mod_tot['city_district'] == 'Истринский'].empty:
    pass
else:
    new_data = pd.DataFrame({
        'district': ['МО'],
        'city_district': ['Истринский'],
        'coordinates': [None],
        'lon': [coordinates_istra['lon']],
        'lat': [coordinates_istra['lat']]
    })
    # Добавление новой строки в DataFrame
    geo_mo_mod_tot = pd.concat([geo_mo_mod_tot, new_data], ignore_index=True)

#geo_mo_mod_tot.to_excel('C:/Users/GAV/Desktop/Study/BA/PythonScripts/Pets/MoscDep/geo_mo_mod_tot.xlsx', index=False)


#     Вывод:
#         1. в датаферйме oblects (Объекты) нет ни одного объекта самостроя в районе Теплый стан и Котловка, что странно, так как в остальных 144 районах есть самострой, а в этих двух нет.
#         2. Есть одни объект в районе Истринский, который находится в области, как он попал в объекты по г. Москва не понятно.

# In[15]:


# Добавим координаты районов в датафрейм с объектами
#geo_mo_mod_tot.to_excel('C:/Users/GAV/Desktop/Study/BA/PythonScripts/Pets/MoscDep/geo_mo_mod_tot.xlsx', index=False)
objects_df = objects_df.merge(geo_mo_mod_tot[['city_district', 'lon', 'lat']], left_on='Район', right_on='city_district', how='left')
objects_df.drop(columns ='city_district', inplace=True)


# In[16]:


objects_df.info()


# Присвоили координаты всем объектам, за исключением Истринского, который в МО.

# In[17]:


objects_df['Округ'].unique()


# In[18]:


# Добавим колонку с названиями округов в формате GeoJSON
# Словарь маппинга между аббревиатурами DataFrame и полными названиями из GeoJSON
mapping_dict = {
    'ЦАО': 'Центральный',
    'ЮВАО': 'Юго-Восточный',
    'ВАО': 'Восточный',
    'СВАО': 'Северо-Восточный',
    'ЮАО': 'Южный',
    'САО': 'Северный',
    'ЗАО': 'Западный',
    'СЗАО': 'Северо-Западный',
    'ЗЕЛАО': 'Зеленоградский',
    'НАО': 'Новомосковский',
    'ТАО': 'Троицкий',
    'ЮЗАО': 'Юго-Западный',
    'МО': 'Московская область' 
}
events_df['GeoJSON_Name'] = events_df['Округ'].map(mapping_dict)
events_df.info()


# In[19]:


# Добавим колонку с названиями районов в формате GeoJSON
# Словарь маппинга между аббревиатурами DataFrame и полными названиями из GeoJSON
mapping_dict_mo = {
  '«Мосрентген»' :  '"Мосрентген"',
  'Академический' : 'Академический',
  'Алексеевский' : 'Алексеевский',
  'Алтуфьевский' : 'Алтуфьевский',
  'Арбат' : 'Арбат',
  'Аэропорт' : 'Аэропорт',
  'Бабушкинский' : 'Бабушкинский',
  'Басманный' : 'Басманный',
  'Беговой' : 'Беговой',
  'Бескудниковский' : 'Бескудниковский',
  'Бибирево' : 'Бибирево',
  'Бирюлево Восточное' : 'Бирюлёво Восточное',
  'Бирюлево Западное' : 'Бирюлёво Западное',
  'Богородское' : 'Богородское',
  'Братеево' : 'Братеево',
  'Бутырский' : 'Бутырский',
  'Вешняки' : 'Вешняки',
  'Внуково' : 'Внуково',
  'Внуковское' : 'Внуковское',
  'Войковский' : 'Войковский',
  'Вороновское' : 'Вороновское',
  'Воскресенское' : 'Воскресенское',
  'Восточное Дегунино' : 'Восточное Дегунино',
  'Восточное Измайлово' : 'Восточное Измайлово',
  'Восточный' : 'Восточный',
  'Выхино-Жулебино' : 'Выхино-Жулебино',
  'Гагаринский' : 'Гагаринский',
  'Головинский' : 'Головинский',
  'Гольяново' : 'Гольяново',
  'Даниловский' : 'Даниловский',
  'Десеновское' : 'Десёновское',
  'Дмитровский' : 'Дмитровский',
  'Донской' : 'Донской',
  'Дорогомилово' : 'Дорогомилово',
  'Замоскворечье' : 'Замоскворечье',
  'Западное Дегунино' : 'Западное Дегунино',
  'Зюзино' : 'Зюзино',
  'Зябликово' : 'Зябликово',
  'Ивановское' : 'Ивановское',
  'Измайлово' : 'Измайлово',
  'Капотня' : 'Капотня',
  'Киевский' : 'Киевский',
  'Кленовское' : 'Клёновское',
  'Кокошкино' : 'Кокошкино',
  'Коньково' : 'Коньково',
  'Коптево' : 'Коптево',
  'Косино-Ухтомский' : 'Косино-Ухтомский',
  'Котловка' : 'Котловка',
  'Краснопахорское' : 'Краснопахорское',
  'Красносельский' : 'Красносельский',
  'Крылатское' : 'Крылатское',
  'Крюково' : 'Крюково',
  'Кузьминки' : 'Кузьминки',
  'Кунцево' : 'Кунцево',
  'Куркино' : 'Куркино',
  'Левобережный' : 'Левобережный',
  'Лефортово' : 'Лефортово',
  'Лианозово' : 'Лианозово',
  'Ломоносовский' : 'Ломоносовский',
  'Лосиноостровский' : 'Лосиноостровский',
  'Люблино' : 'Люблино',
  'Марушкинское' : 'Марушкинское',
  'Марфино' : 'Марфино',
  'Марьина Роща' : 'Марьина Роща',
  'Марьино' : 'Марьино',
  'Матушкино' : 'Матушкино',
  'Метрогородок' : 'Метрогородок',
  'Мещанский' : 'Мещанский',
  'Митино' : 'Митино',
  'Михайлово-Ярцевское' : 'Михайлово-Ярцевское',
  'Можайский' : 'Можайский',
  'Молжаниновский' : 'Молжаниновский',
  'Москворечье-Сабурово' : 'Москворечье-Сабурово',
  'Московский' : 'Московский',
  'Нагатино-Садовники' : 'Нагатино-Садовники',
  'Нагатинский Затон' : 'Нагатинский Затон',
  'Нагорный' : 'Нагорный',
  'Некрасовка' : 'Некрасовка',
  'Нижегородский' : 'Нижегородский',
  'Новогиреево' : 'Новогиреево',
  'Новокосино' : 'Новокосино',
  'Ново-Переделкино' : 'Ново-Переделкино',
  'Новофедоровское' : 'Новофёдоровское',
  'Обручевский' : 'Обручевский',
  'Орехово-Борисово Северное' : 'Орехово-Борисово Северное',
  'Орехово-Борисово Южное' : 'Орехово-Борисово Южное',
  'Останкинский' : 'Останкинский',
  'Отрадное' : 'Отрадное',
  'Очаково-Матвеевское' : 'Очаково-Матвеевское',
  'Первомайское' : 'Первомайское',
  'Перово' : 'Перово',
  'Печатники' : 'Печатники',
  'Покровское-Стрешнево' : 'Покровское-Стрешнево',
  'Преображенское' : 'Преображенское',
  'Пресненский' : 'Пресненский',
  'Проспект Вернадского' : 'Проспект Вернадского',
  'Раменки' : 'Раменки',
  'Роговское' : 'Роговское',
  'Ростокино' : 'Ростокино',
  'Рязановское' : 'Рязановское',
  'Рязанский' : 'Рязанский',
  'Савелки' : 'Савёлки',
  'Савеловский' : 'Савёловский',
  'Свиблово' : 'Свиблово',
  'Северное Бутово' : 'Северное Бутово',
  'Северное Измайлово' : 'Северное Измайлово',
  'Северное Медведково' : 'Северное Медведково',
  'Северное Тушино' : 'Северное Тушино',
  'Северный' : 'Северный',
  'Силино' : 'Силино',
  'Сокол' : 'Сокол',
  'Соколиная Гора' : 'Соколиная Гора',
  'Сокольники' : 'Сокольники',
  'Солнцево' : 'Солнцево',
  'Сосенское' : 'Сосенское',
  'Старое Крюково' : 'Старое Крюково',
  'Строгино' : 'Строгино',
  'Таганский' : 'Таганский',
  'Тверской' : 'Тверской',
  'Текстильщики' : 'Текстильщики',
  'Теплый Стан' : 'Тёплый Стан',
  'Тимирязевский' : 'Тимирязевский',
  'Троицк' : 'Троицк',
  'Тропарево-Никулино' : 'Тропарёво-Никулино',
  'Филевский Парк' : 'Филёвский Парк',
  'Фили-Давыдково' : 'Фили-Давыдково',
  'Филимонковское' : 'Филимонковское',
  'Хамовники' : 'Хамовники',
  'Ховрино' : 'Ховрино',
  'Хорошево-Мневники' : 'Хорошёво-Мнёвники',
  'Хорошевский' : 'Хорошёвский',
  'Царицыно' : 'Царицыно',
  'Черемушки' : 'Черёмушки',
  'Чертаново Северное' : 'Чертаново Северное',
  'Чертаново Центральное' : 'Чертаново Центральное',
  'Чертаново Южное' : 'Чертаново Южное',
  'Щаповское' : 'Щаповское',
  'Щербинка' : 'Щербинка',
  'Щукино' : 'Щукино',
  'Южное Бутово' : 'Южное Бутово',
  'Южное Медведково' : 'Южное Медведково',
  'Южное Тушино' : 'Южное Тушино',
  'Южнопортовый' : 'Южнопортовый',
  'Якиманка' : 'Якиманка',
  'Ярославский' : 'Ярославский',
  'Ясенево' : 'Ясенево'
}
events_df['GeoJSON_Name_mo'] = events_df['Район'].map(mapping_dict_mo)
events_df.info()


# ### Отбор и объединение данных в один датафрейм со всеми необходимыми для анализа признаками

# Так как датафреймы содержат большой объем данных, сформируем один, в котором оставим только необходимую информацию:
#            
#            1. из tasks - № распоряжения/поручения (первичный ключ), 
#                        - Источник задачи.
#           
#            3. из events: 
#                            - Идентификатор мероприятия, 
#                            - № проверки (ссылочный ключ к tasks)
#                            - Вид мероприятия
#                            - Дата проверки/обсл
#                            - Результат
#                            - Наличие нарушения
#                            - Проверка/обсл. в отношении
#                            - Фактическое использование
#                            - Округ
#                            - Район
#                            - ID объекта самостроя (ссылочный ключ к objects)
#                            
#             2. из object:
#                            - Идентификатор объекта (первичный ключ)
#                            - Тип объекта
#                            - Площадь объекта
#                            - Демонтирован
#                            - Дата демонтажа
#                            - Отложенный демонтаж
#                            

#     Объединим данные events в итоговый датафрейм присоединив tasks и objects
#     Предварительно сверим ссылочные ключи

# In[20]:


#проверим совпадение ключей в events_df и tasks_df
events_tascs_id = set(events_df['№ проверки'].unique())
tasks_id = set(tasks_df['№ распоряжения/поручения'].unique())

print("Ключи присутствуют только в events_tascs_id:", events_tascs_id - tasks_id)
print("Ключи присутствуют только в tascs_id:", tasks_id - events_tascs_id)


# In[21]:


#проверим совпадение ключей в events_df и objects_df
events_tascs_id = set(events_df['ID объекта самостроя'].unique())
objects_id = set(objects_df['Идентификатор объекта'].unique())

print("Присутствуют только в events_tascs_id:", events_tascs_id - objects_id)
print("Присутствуют только в objects_id:", objects_id - events_tascs_id)


# Ключи совпадают, можно объединять df.

# In[22]:


df_total = pd.DataFrame()
#объединяем events_df и tasks_df
df_total = events_df[['Идентификатор мероприятия', '№ проверки', 'Вид мероприятия', 'Дата проверки/обсл', 'Время начала осмотра', 'Продолжительность (час)', 'Результат', 'Наличие нарушения', 'Проверка/обсл. в отношении', 'Фактическое использование',
                      'Округ', 'Район', 'ID объекта самостроя', 'GeoJSON_Name', 'GeoJSON_Name_mo']].merge(tasks_df[['№ распоряжения/поручения', 'Источник задачи']], left_on='№ проверки', right_on='№ распоряжения/поручения', how='left')
df_total.drop(columns='№ распоряжения/поручения', inplace=True)
df_total.info()


# In[23]:


#объединяем objects_df
df_total = df_total.merge(objects_df[['Идентификатор объекта', 'Тип объекта', 'Площадь объекта', 'Демонтирован', 'Дата демонтажа', 'Отложенный демонтаж', 'lon', 'lat']], left_on='ID объекта самостроя', right_on='Идентификатор объекта', how='left')
df_total.drop(columns='Идентификатор объекта', inplace=True)
df_total.info()


# 
# Проверим полученный датафрейм еще раз на неявные дуликаты по признакам:
# 
#         - № проверки
#         - ID объекта самостроя
#         - Дата проверки/обсл
#         - Время начала осмотра
#         - Продолжительность (час)
#   Если эти признаки совпадают, то информация о проверке внесена несколько раз по одному и тому же объекту

# In[24]:


print('Найдено дубликатов', df_total[['№ проверки', 'ID объекта самостроя', 'Дата проверки/обсл', 'Время начала осмотра',
          'Продолжительность (час)']].duplicated().sum())


# In[25]:


df_total = df_total.drop_duplicates(subset=['№ проверки', 'ID объекта самостроя', 'Дата проверки/обсл', 'Время начала осмотра',
          'Продолжительность (час)'])


# In[26]:


df_total.info()


# In[27]:


#df_total.to_excel('C:/Users/GAV/Desktop/Study/BA/PythonScripts/Pets/MoscDep/df_total.xlsx', index=False)


# ### Вывод по загрузке предобрадотке данных:
#         
#         1. загрузили данные из 3-х таблиц
#         2. проверили на пропуски и дубликаты
#         3. скорректировали типы данных
#         4. дообогатили данные геокоординатами центров районов города
#         5. проверили соответствие ссылочных ключей и объединили данные в один датафрейм, отобрав необходимые для анализа признаки.

# ## Исследовательский анализ

# In[28]:


# здесь и далее строки st. для выгрузки графиков, комментариев к ним в Streamlit
st.title('Анализ результатов мониторинга земельных участков на территории города Москвы')
st.subheader('Данные мониторинга за период 01.2023 по 03.2024 г.')
st.subheader('Цель исследования:')
st.subheader('Подготовить анализ данных о проверках, направленных выявление незаконных строительных объектов, с визуализацией информации по объектам, количеству проведенных мероприятий и их результатах.')
st.write("""Автор: Горбуля Андрей
""")
st.write("""Дата исследования: Апрель 2024 г.
""")


# ### Анализ общего количества выявленных объектов самостроя по округам

# In[29]:


st.header('Раздел 1. Анализ общего количества выявленных объектов самостроя по округам г.Москвы')


# In[30]:


# Подсчитываем общее количество объектов самостроя в каждом округе
district_total_counts = df_total.query('Результат != "Отсутствие самостроя"').groupby(['Округ', 'GeoJSON_Name'])['ID объекта самостроя'].nunique(
).reset_index(name='total_counts').sort_values(by='total_counts', ascending=False)
print(district_total_counts)
print('Всего объектов самостроя', district_total_counts['total_counts'].sum())


# #### Количество и распределение объектов самостроя по округам г. Москвы

# In[31]:


st.subheader('1.1. Количество и распределение объектов самостроя по округам г. Москвы')
st.write("""Выводы:
1. Всего за период с 01.2023 по 03.2024 г. выявлено 2726 объектов самостроя.
2. Лидеры по количеству объектов самостроя: ЦАО, ЮВАО и ВАО, СВАО. В этих районах находятся около 60% всех объектов самостроя.
3. Меньше всего выявлено объектов самостроя в ЮЗАО - 1,5%.
""")


# In[32]:


# Установим цветовые схемы
color_templ_3 = dict(zip(district_total_counts.loc[:, ['Округ']]
                      .groupby(by=['Округ'])
                      .sum()
                      .index.to_list(),
                      px.colors.qualitative.Safe))

# Создаем сетку с двумя графиками: один баровая диаграмма, другой круговая диаграмма
fig = make_subplots(rows=1, cols=2, specs=[[{"type": "bar"}, {"type": "pie"}]], 
                    column_widths=[0.7, 0.3],  # Ширина колонок
                    row_heights=[0.5])         # Высота строк

# Добавляем баровую диаграмму
fig.add_trace(
    go.Bar(x=district_total_counts['Округ'],
           y=district_total_counts['total_counts'],
           text=district_total_counts['total_counts'].astype(str),
           marker_color=list(color_templ_3.values()), 
           textposition='auto',
           showlegend=False),
    row=1, col=1
)

# Добавляем круговую диаграмму
fig.add_trace(
    go.Pie(values=district_total_counts['total_counts'],
           labels=district_total_counts['Округ'],
           hoverinfo='label+percent',
           marker_colors=list(color_templ_3.values()),
           showlegend=True
           ),
    row=1, col=2
)

# Обновляем макет для баровой диаграммы
fig.update_xaxes(title_text="Округ", row=1, col=1)
fig.update_yaxes(title_text="Количество объектов, шт.", row=1, col=1)

# Обновляем макет
fig.update_layout(title_text='Количество и распределение объектов самостроя по округам г. Москвы',
                 plot_bgcolor='rgba(0,0,0,0)',
                 legend_title="Округ"
                 )

# Показываем график
#fig.show();
st.plotly_chart(fig)


#     Вывод:
#         1. Всего 2726 объектов самостроя.
#         1. Лидеры по количеству объектов самостроя ЦАО, ЮВАО и ВАО, СВАО. В этих районах находятся около 60% всех объектов самостроя.
#         2.Меньше всего в ЮЗАО - 1,5%.

# #### Визуализация объектов самостроя по округам на карте  г. Москвы

# In[33]:


# отберем объекты для визуализации
df_total_map = df_total[-df_total['lat'].isna()].query('Результат != "Отсутствие самостроя"')
len(df_total_map)


# In[ ]:


st.subheader('1.2. Oбъекты самостроя по округам на карте г. Москвы')
st.write("""Выводы:
1. Особенно выделяются лидеры по объектам самостроя ЦАО и ЮВАО, а за ними следуют ВАО и СВАО.
2. На территориях "Новой Москвы" (НАО, ТАО) и ЮЗАО выявлено меньше всего таких объектов.
""")


# In[138]:


# moscow_lat - широта центра Москвы, moscow_lng - долгота центра Москвы
moscow_lat, moscow_lng = 55.751244, 37.618423

# создаём карту Москвы
m = Map(location=[moscow_lat, moscow_lng], zoom_start=10, tiles="Cartodb Positron")
# создаём пустой кластер, добавляем его на карту
marker_cluster = MarkerCluster().add_to(m)

# пишем функцию, которая принимает строку датафрейма,
# создаёт маркер в текущей точке и добавляет его в кластер marker_cluster
def create_clusters(row):
    Marker(
        [row['lon'], row['lat']],
        popup=f"{row['Район']}",
    ).add_to(marker_cluster)

# применяем функцию create_clusters() к каждой строке датафрейма
df_total_map.apply(create_clusters, axis=1)

# загружаем JSON-файл с границами округов Москвы

try:
    url = 'https://raw.githubusercontent.com/AVGorbulya/Yandex_Master/main/ao.geojson'
    response = requests.get(url)
    data = response.content
    geo_json_data = json.loads(data)  # Используем json.loads для прямой загрузки из байтов
except Exception as e:
    print("Ошибка при загрузке с удаленного источника:", e)
    state_geo_mo = 'C:\\Users\\GAV\\Desktop\\Study\\BA\\PythonScripts\\Datasets\\ao.geojson'
    with open(state_geo_mo, 'r', encoding='utf-8') as file:
        geo_json_data = json.load(file)

# создаём хороплет с помощью конструктора Choropleth и добавляем его на карту
Choropleth(
    geo_data=geo_json_data,
    data=district_total_counts,
    columns=['GeoJSON_Name', 'total_counts'],
    key_on='feature.properties.NAME',
    fill_color='YlOrBr',
    fill_opacity=0.8,
    legend_name='Количество объектов самостроя по округам г.Москвы',
).add_to(m)

# выводим карту
#m
folium_static(m)


# Вывод:
#         
#        1. На карте также хорошо видно, что лидеры по объектам самостроя ЦАО и ЮВАО, а за ними следуют ВАО и СВАО.
#        2. На территориях "новой Москвы" (НАО, ТАО) и ЮЗАО меньше всего таких объектов выявлено.

# #### Анализ типов объектов самостроя в разрезе округов г. Москвы

# In[35]:


# расчет структуры типов объектов по округам
# Группируем данные по районам и типам, подсчитываем количество объектов
district_category_counts = df_total.groupby(['Округ', 'Тип объекта']).size().reset_index(name='counts')

# Объединяем данные с общим количеством проверок
district_category_counts = district_category_counts.merge(district_total_counts[['Округ','total_counts']], on='Округ')

# Вычисляем долю каждого типа от общего числа объектов в районе
district_category_counts['category_share'] = district_category_counts['counts'] / district_category_counts['total_counts']

# Сортируем данные
district_category_counts = district_category_counts.sort_values(by=['counts'], ascending=[False])

print(district_category_counts)


# In[ ]:


st.subheader('1.3. Анализ типов объектов самостроя в разрезе округов г. Москвы')
st.write("""Выводы:
   1. Существенное количество объектов от 20% до 64% в большинстве округов классифицировано как прочее. Необходимо разработать подход к унификации справочника типов объектов, так как сейчас помимо существенной доли  неопределенного типа объектов, есть и неявные дубли в классификации (например, ГСК и гараж, строение и отдельное строение).
   2. В лидерах количеству объектов самостроя: пристройка, строение, надстройка, здание.
   3. В ЦАО выделяются также мансарды с долей 6%.
""")


# In[36]:


# Установим цветовые схемы
color_templ = dict(zip(df_total.loc[:, ['Тип объекта']]
                      .groupby(by=['Тип объекта'])
                      .sum()
                      .index.to_list(),
                      px.colors.qualitative.Pastel))
# Строим bar chart
fig = px.bar(district_category_counts, x='Округ', y='counts', color='Тип объекта', text='category_share',
             title='Распределение типовых объектов самостроя по округам г.Москвы',
             labels={'Округ': 'Округ', 'counts': 'Количество объектов, шт.', 'Тип объекта': 'Тип объекта'},
             hover_data={'category_share': ':.1f'},
             color_discrete_sequence=list(color_templ.values()),
             category_orders={'Округ': district_category_counts.groupby('Округ')['counts'].sum() \
                                                     .sort_values(ascending=False) \
                                                     .index.to_list()}
            )
             
# Обновляем макет, убираем подложку grid и фон
fig.update_layout(
    xaxis=dict(showgrid=False),
    yaxis=dict(showgrid=False, dtick=150),
    plot_bgcolor='rgba(0,0,0,0)',
    height=700,  
    width=1000   
)
fig.update_traces(texttemplate='%{text:.0%}', textfont_size=12, textangle=0, textposition="inside")

# Отображаем график
#fig.show()
st.plotly_chart(fig) 


# Вывод:
#        
#        1. Существенное количество объектов от 20% до 64% в большинстве классифицировано как прочее. Необходимо разработать подход к унификации справочника типов объектов, так как сейчас помимо существенной доли  неопределенного типа объектов, есть и неявные дубли в классификации (например, ГСК и гараж, строение и отдельное строение).
#        2. В лидерах по типам объектов самостроя: пристройка, строение, надстройка, здание.
#        3. В ЦАО выделяются также мансарды с долей 6%.

# #### Анализ общих характеристик типов объектов самостроя

# ##### Анализ объектов по размеру площади

# In[37]:


df_total_group = df_total.groupby('Тип объекта')['Площадь объекта'].median()
print(df_total_group)


# In[38]:


# таблица с описанием площади по типам объектов
description_square = df_total.groupby('Тип объекта')['Площадь объекта'].describe()
print(description_square)


# Вывод:
# 
#     Большие значения стандартных отклонений и существенно низкие медианы указывают высокий разброс значений площади по типам объектов.

# In[39]:


# Посмотрим на 90-й, 95-й и 99-й процентиль по каждому типу объекта
percentiles_table_square = df_total.groupby('Тип объекта')['Площадь объекта'].agg([
    ('90%', lambda x: np.percentile(x, 90)),  # 90-й процентиль
    ('95%', lambda x: np.percentile(x, 95)),  # 95-й процентиль
    ('99%', lambda x: np.percentile(x, 99))   # 99-й процентиль
])

print(percentiles_table_square)


# In[ ]:


st.subheader('1.4. Анализ типовых объектов самостроя по размеру площади г. Москвы')
st.write("""Выводы:
1. Самые крупные объекты самостроя по размеру площади: надстройки и мансарды (с медианой площадью 737 и 650 кв. м.)
2. При этом площади всех типов объектов имеют существенный разброс, что может говорить о необходимости уточнения этих параметров в базе данных.
""")


# In[40]:


# Создание боксплота по категориям
fig = px.box(df_total[['Тип объекта', 'Площадь объекта']], 
             x='Тип объекта', 
             y='Площадь объекта', 
             color='Тип объекта', 
             color_discrete_sequence=list(color_templ.values()), 
             points = False,
             hover_data=df_total[['Тип объекта', 'Площадь объекта']].columns,
             category_orders={'Тип объекта': df_total.groupby(by=['Тип объекта'])['Площадь объекта'] \
                                                     .median() \
                                                     .sort_values(ascending=True)\
                                                     .index.to_list()}
               )


# Настройка заголовка и осей
fig.update_layout(title='Типы объектов самостроя по размеру площади, в кв. м',
                  xaxis_title='Тип объекта',
                  yaxis_title='Площадь объекта, кв. м',
                  yaxis_range=[0, 2500],
                  plot_bgcolor='rgba(0,0,0,0)'
                 )

# Убираем легенду
for trace in fig.data:
    trace.showlegend = False

# Показ графика
#fig.show()
st.plotly_chart(fig) 


# Вывод:
#         
#         1. Самые крупные по площади объекты самостроя: 50% надстроек и мансард с медианной площадью до 730 и 650 кв. м. соответственно, еще 25% этих объектов с площадь. до 2400 кв. м.
#         2. 50% заборов, ангаров с медианной площадью от 350 до 400 кв. м., зданий, ГСК и прочих объектов - около 300 кв. м.
#         3. 50% гаражей, строений, павильонов и пристроек имеют площадь от 65 до 150 кв. м., при этои у 25% пристроек площадь достигает 890 кв. м.        

# ### Анализ количества проверок по районам

# In[ ]:


st.header('Раздел 2. Анализ количества проверок по районам г.Москвы')


# #### Анализ количества проверок по объектам

# In[41]:


#период за который представлена база проверок
print(df_total['Дата проверки/обсл'].min())
print()
print(df_total['Дата проверки/обсл'].max())


# База проверок охватывает период с 09.01.2023 по 28.03.2024 гг

# In[42]:


#рассчитаем количество проверок, приходящихся на 1 объект
description_hist = df_total.groupby('ID объекта самостроя')['№ проверки'].count(
).sort_values(ascending=False).value_counts().reset_index()
print(description_hist)
print('Всего проверок', df_total['№ проверки'].count())
print('Всего проверено объектов', df_total['ID объекта самостроя'].nunique())


# In[ ]:


st.subheader('2.1. Анализ количества проверок объектов г. Москвы')
st.write("""Выводы:
1. В основном за представленный период с января 2023 по март 2024 97% выявленных объектов проверены 1 раз. 
2. Около 3% - проверены дважды.
""")


# In[84]:


# график количества проверок по объектам
fig = px.bar(description_hist, x='№ проверки', y='count',
             color_discrete_sequence=list(color_templ_3.values()),
             labels={'count': 'Количество объектов, шт', '№ проверки': 'Количество проверок, шт.'},
             title='Количество проверок по объектам за период')

# Отображение графика в Streamlit
st.plotly_chart(fig)
#fig.show()


# Вывод:
#         
#         1. В основном за представленный период с января 2023 по март 2024 97% выявленных объектов проверены 1 раз, 2.99% - проверены дважды.
# 

# #### Анализ количества проверок и выявленных нарушений в месяц 

# In[44]:


# сформируем колонку с признаком выявленного/невыявленного нарушения для строительства гистограммы
hist_events = df_total.copy()
hist_events['Результат_проверки'] = hist_events['Результат'].apply(
    lambda x: "Не выявлено нарушение" if x == "Отсутствие самостроя" else "Выявлено нарушение"
)


# In[45]:


# посмотрим скольок в среднем в месяц проверок
hist_events['Месяц'] = hist_events['Дата проверки/обсл'].dt.to_period('M')
hist_events_description = hist_events.groupby(['Месяц'])['№ проверки'].count().describe()
print(hist_events_description)


#     В среднем 209 проверок в месяц, минимальное количество 40, максимальное 292.
#     Минимально 40 в марте 2024 г. Возможно не полная база.
# 
#     Посмотрим на количество выявленных нарушений.

# In[75]:


#рассчитаем количество проверок и нарушений по месяцам
hist_events_count1 = hist_events.query('Результат_проверки == "Выявлено нарушение"').groupby(['Месяц','Результат_проверки'])['№ проверки'].count().reset_index()
hist_events_count2 = hist_events.query('Результат_проверки == "Не выявлено нарушение"').groupby(['Месяц','Результат_проверки'])['№ проверки'].count().reset_index()
hist_events_count = hist_events_count1.merge(hist_events_count2[['Месяц','№ проверки']], how='left', on='Месяц')
hist_events_count.drop(columns='Результат_проверки', inplace=True)
hist_events_count = hist_events_count.rename(
    columns={'Месяц': 'Месяц', '№ проверки_x': "Выявлено нарушение", '№ проверки_y': "Не выявлено нарушение"})
hist_events_count['share_%'] = ((hist_events_count['Выявлено нарушение'] / \
    hist_events_count[['Выявлено нарушение',
                        'Не выявлено нарушение']].sum(axis=1))*100).round(0)
print(hist_events_count)
print('Всего проверок', df_total['№ проверки'].count())
print('Всего выявлено нарушений', hist_events_count['Выявлено нарушение'].sum())
print('Всего не выявлено нарушений', hist_events_count['Не выявлено нарушение'].sum())


# In[47]:


print(hist_events_count['share_%'].describe())


# Вывод:
# 
#     В  среднем в 92% случаев выявляется нарушение при проверке.
#     Построим график проверок и выявленных нарушений за период.

# In[ ]:


st.subheader('2.2. Анализ количества проверок и выявленных нарушений в месяц ')
st.write("""Выводы:
1. В среднем в месяц проводится 209 проверок (медианое значение).
2. Больше всего проверок было проведено в марте, апреле, октябре 2023 и феврале 2024 г.
3. В среднем в 92% случаях проверки выявляют нарушения.
""")


# In[175]:


fig = px.histogram(hist_events, 
                   x='Дата проверки/обсл',
                   nbins=20,
                   color='Результат_проверки', 
                   title='Частота и результат проверок за период',
                   color_discrete_sequence=list(px.colors.qualitative.Pastel)
                   
                  )
# Настройка заголовка и осей
fig.update_layout(
                  
                  yaxis_title='Количество проверок, шт',
                  yaxis_range=[100, 300],
                  plot_bgcolor='rgba(0,0,0,0)'
                 )

# Добавление горизонтальной линии на уровне Y=209
fig.add_shape(type='line',
              
              x0=hist_events['Дата проверки/обсл'].min(),  
              y0=209,  
              x1=hist_events['Дата проверки/обсл'].max(),  
              y1=209,  
              line=dict(color='Red', width=2, dash='dash') 
)

fig.add_annotation(
    x=hist_events['Дата проверки/обсл'].mean(), 
    y=209+7,  
    text="209 проверок в среднем в месяц", 
    showarrow=False,  
    font=dict(color="Red", size=15)
       
)

#fig.show()
st.plotly_chart(fig) 


# Вывод:
#         
#         1. В среднем в месяц проводится 209 проверок (медиана).
#         3. Больше всего проверок было проведено в марте, апреле, октябре 2023 и феврале 2024 г.
#         2. В среднем в 92% случаях проверки выявляют нарушения.

# #### Анализ количества проверок по районам г. Москвы

# In[115]:


# Подсчитываем общее количество проверок в каждом районе Москвы
city_district_total_counts = df_total.query('Район != "Истринский"').groupby(['GeoJSON_Name_mo', 'Район'])['ID объекта самостроя'].count(
).reset_index(name='total_counts').sort_values(by='total_counts', ascending=False)
print(city_district_total_counts.head(10))
print('Всего проверок самостроя', city_district_total_counts['total_counts'].sum())


# In[50]:


print(city_district_total_counts.describe())


# In[ ]:


st.subheader('2.3. Анализ частоты проверок по районам г. Москвы.')
st.write("""Выводы:
В среднем за год в районах проводится около 15 проверок, при этом:
- в 15 районах за год проведено от 1 до 3 проверок.
- в 15 районах за год проведено от  40 до 201 проверки.
""")


# In[103]:


# Создание гистограммы с использованием Plotly Express
fig = px.histogram(city_district_total_counts, x='total_counts',
                   nbins=50,  
                   title='Частота проверок по районам г. Москвы',
                   labels={'total_counts': 'Количество проверок, шт'},
                   marginal='box',  # 'rug' для коврика, 'box' для боксплота, или 'violin' для скрипичного графика
                   color_discrete_sequence=list(px.colors.qualitative.Pastel))  # Цвет гистограммы

# Настройка осей
fig.update_xaxes(tickvals=list(range(0, 205, 15))) 
fig.update_yaxes(title='Районы, ед.')


# Отображение графика в Streamlit
st.plotly_chart(fig)
#fig.show()


# In[52]:


print(city_district_total_counts.reset_index().head(15
                               ))


# Вывод:
#     
#     В среднем за год в районах проводится около 15 проверок, при этом:
#         - в 15 районах за год проведено от 1 до 3 проверок.
#         - в 15 районах за год проведено от 40 до 201 проверки.
#         

# Прежде чем загрузить данные на карту, сверим ключи районов в geojson и city_district_total_counts

# In[143]:


# Загрузка GeoJSON файла
try:
    url = 'https://raw.githubusercontent.com/AVGorbulya/Yandex_Master/main/mos_map.geojson'
    response = requests.get(url)
    data = response.content
    geo_json_data = json.loads(data.decode('utf-8'))  # Декодирование данных перед загрузкой
except Exception as e:
    print("Ошибка при загрузке с удаленного источника:", e)
    state_geo_mo = 'C:\\Users\\GAV\\Desktop\\Study\\BA\\PythonScripts\\Datasets\\mos_map.geojson'
    with open(state_geo_mo, 'r', encoding='utf-8') as file:
        geo_json_data = json.load(file)

# Извлечение названий округов
state_geo_city_district = [feature['properties']['NAME'] for feature in geo_json_data['features']]

print(len(state_geo_city_district))


# In[144]:


#проверим совпадение ключей районов в state_geo_city_district файла geo_mo_mod.geojson и city_district_total_counts
state_geo_mo_set = set(state_geo_city_district)
set_city_district_df = set(city_district_total_counts['GeoJSON_Name_mo'].unique())

print("Ключи присутствуют только в state_geo_mo_set:", state_geo_mo_set - set_city_district_df)
print("Ключи присутствуют только в set_city_district_df:", set_city_district_df - state_geo_mo_set)


# Проверка пройдена, в файле gmos_map.geojson есть все районы, в которых проводились проверки.

# In[ ]:


st.subheader('2.4. Количество проверок по районам на карте г. Москвы.')
st.write("""Выводы:
1. Лидеры по числу проверок Басманный район и Печатники, следом идут Таганский и Соколиная Гора.
2. Нет информации о проверках в районах Теплый стан и Котловка. Либо их не проверяли за весь год, либо база не полная.
""")


# In[146]:


# moscow_lat - широта центра Москвы, moscow_lng - долгота центра Москвы
moscow_lat, moscow_lng = 55.751244, 37.618423

# создаём карту Москвы
m = Map(location=[moscow_lat, moscow_lng], zoom_start=10, tiles='Cartodb Positron')
# создаём пустой кластер, добавляем его на карту
marker_cluster = MarkerCluster().add_to(m)

# пишем функцию, которая принимает строку датафрейма,
# создаёт маркер в текущей точке и добавляет его в кластер marker_cluster
def create_clusters(row):
    Marker(
        [row['lon'], row['lat']],
        popup=f"{row['Район']}",
    ).add_to(marker_cluster)

# отфильтруем только районы Москвы
filtered_df = df_total[df_total['Район'].map(lambda x: x in mapping_dict_mo)]
# применяем функцию create_clusters() к каждой строке датафрейма
filtered_df.apply(create_clusters, axis=1)

# загружаем JSON-файл с границами округов Москвы
try:
    url = 'https://raw.githubusercontent.com/AVGorbulya/Yandex_Master/main/mos_map.geojson'
    response = requests.get(url)
    data = response.content
    geo_json_data = json.loads(data)  
except Exception as e:
    print("Ошибка при загрузке с удаленного источника:", e)
    state_geo_mo = 'C:\\Users\\GAV\\Desktop\\Study\\BA\\PythonScripts\\Datasets\\mos_map.geojson'
    with open(state_geo_mo, 'r', encoding='utf-8') as file:
        geo_json_data = json.load(file)

# создаём хороплет с помощью конструктора Choropleth и добавляем его на карту
Choropleth(
    geo_data=geo_json_data,
    data=city_district_total_counts,
    columns=['GeoJSON_Name_mo', 'total_counts'],
    key_on='feature.properties.NAME',
    fill_color='YlOrBr',
    fill_opacity=0.7,
    legend_name='Количество проверок по районам г.Москвы',
).add_to(m)

# выводим карту
#m
folium_static(m) 


# Вывод:
#       
#       1. Лидеры по числу проверок Басманный район и Печатники, следом идут Таганский и Соколиная Гора.
#       2. Нет информации о проверках в районах Теплый стан и Котловка. Либо их не проверяли за весь год, либо база не полная.

# #### Анализ количества выявленных нарушений по районам г.Москвы

# In[56]:


# Подсчитываем общее количество проверок в каждом районе Москвы
city_district_total_violation = df_total.query('(Район != "Истринский") & (Результат != "Отсутствие самостроя")').groupby(['GeoJSON_Name_mo', 'Район'])['ID объекта самостроя'].count(
).reset_index(name='total_counts').sort_values(by='total_counts', ascending=False)
print(city_district_total_violation)
print('Всего выявлено нарушений', city_district_total_violation['total_counts'].sum())


# In[57]:


print(city_district_total_violation.describe())


# In[ ]:


st.subheader('2.5 Частота выявления нарушений по районам г. Москвы.')
st.write("""Выводы:
В среднем за год в районах выявлено около 13 нарушений, при этом:
- в 15 районах за год выявлено от 1 до 3 нарушений.
- в 15 районах за год выявлено от  37 до 178 нарушений.
""")


# In[113]:


# Создание гистограммы с использованием Plotly Express
fig = px.histogram(city_district_total_violation, x='total_counts',
                   nbins=50,  
                   title='Частота выявления нарушений по районам г. Москвы',
                   labels={'total_counts': 'Количество нарушений, шт'},
                   marginal='box',  # 'rug' для коврика, 'box' для боксплота, или 'violin' для скрипичного графика
                   color_discrete_sequence=list(px.colors.qualitative.Pastel1))  # Цвет гистограммы

# Настройка осей
fig.update_xaxes(tickvals=list(range(0, 205, 15))) 
fig.update_yaxes(title='Районы, ед.')


# Отображение графика в Streamlit
st.plotly_chart(fig)
#fig.show()


# In[59]:


print(city_district_total_violation.head(15
                               ))


# Вывод:
# 
#     В среднем за год в районах выявляют около 13 нарушений, при этом:
#         - в 15 районах за год выявлено от 1 до 3 нарушений.
#         - в 15 районах за год выявлено от  37 до 178 нарушений.
# 

# In[ ]:


st.subheader('2.6 Количество выявленных нарушений по районам г.Москвы')
st.write("""Выводы:
1. Лидеры по числу нарушений Басманный район и Печатники.
2. Фактически данные о количестве нарушений повторяют информацию о количестве проверок, то есть, где больше проверяют, там выявляют больше нарушений.
""")


# In[149]:


# moscow_lat - широта центра Москвы, moscow_lng - долгота центра Москвы
moscow_lat, moscow_lng = 55.751244, 37.618423

# создаём карту Москвы
m = Map(location=[moscow_lat, moscow_lng], zoom_start=10, tiles='Cartodb Positron')
# создаём пустой кластер, добавляем его на карту
marker_cluster = MarkerCluster().add_to(m)

# пишем функцию, которая принимает строку датафрейма,
# создаёт маркер в текущей точке и добавляет его в кластер marker_cluster
def create_clusters(row):
    Marker(
        [row['lon'], row['lat']],
        popup=f"{row['Район']}",
    ).add_to(marker_cluster)

# отфильтуем только районы Москвы
filtered_df = df_total[df_total['Район'].map(lambda x: x in mapping_dict_mo)]
filtered_df = filtered_df.query('Результат != "Отсутствие самостроя"')
# применяем функцию create_clusters() к каждой строке датафрейма
filtered_df.apply(create_clusters, axis=1)

# загружаем JSON-файл с границами округов Москвы
try:
    url = 'https://raw.githubusercontent.com/AVGorbulya/Yandex_Master/main/mos_map.geojson'
    response = requests.get(url)
    data = response.content
    geo_json_data = json.loads(data)  
except Exception as e:
    print("Ошибка при загрузке с удаленного источника:", e)
    state_geo_mo = 'C:\\Users\\GAV\\Desktop\\Study\\BA\\PythonScripts\\Datasets\\mos_map.geojson'
    with open(state_geo_mo, 'r', encoding='utf-8') as file:
        geo_json_data = json.load(file)

# создаём хороплет с помощью конструктора Choropleth и добавляем его на карту
Choropleth(
    geo_data=geo_json_data,
    data=city_district_total_counts,
    columns=['GeoJSON_Name_mo', 'total_counts'],
    key_on='feature.properties.NAME',
    fill_color='YlOrBr',
    fill_opacity=0.9,
    legend_name='Количество выявленных нарушений по районам г.Москвы',
).add_to(m)

# выводим карту
#m
folium_static(m) 


# Вывод:
#         
#       1. Лидер по числу нарушений Басманный район и Печатники.
#       2. Фактически данные о количестве нарушений повторяют информацию о количестве проверок, то есть, где больше проверяют, там выявляют больше нарушений.
#     
#     Посмотрим на долю проверок, в которых выявляются нарушения.

# In[73]:


# рассчитаем долю выявленных нарушений от количества проверок по районам
city_district_total_share = pd.DataFrame()
city_district_total_share = city_district_total_counts.merge(
    city_district_total_violation[['Район', 'total_counts']], how='left', on='Район')
city_district_total_share = city_district_total_share.rename(
    columns={'total_counts_x': 'Количество проверок', 'total_counts_y': 'Количество нарушений'})

city_district_total_share['share_%'] = ((city_district_total_share['Количество нарушений']/city_district_total_share['Количество проверок']*100)).round(0)
city_district_total_share.sort_values(by='share_%', ascending=True, inplace=True)
print(city_district_total_share.head())


# In[116]:


print(city_district_total_share.describe())


# In[ ]:


st.subheader('2.7 Доля проверок, выявивших нарушения по районам г.Москвы')
st.write("""Выводы:
1. В 13 районах (с количеством проверок более 15) в 100% случаях при проверке были выявлены нарушения.
2. Районы (с количеством проверок более 15), где от 22% до 43% проверок не выявили нарушений:
        - Капотня
        - Сокольники
        - Щукино
        - Фили-Давыдково
        - Южное Бутово
""")


# In[150]:


# moscow_lat - широта центра Москвы, moscow_lng - долгота центра Москвы
moscow_lat, moscow_lng = 55.751244, 37.618423

# создаём карту Москвы
m = Map(location=[moscow_lat, moscow_lng], zoom_start=10, tiles='Cartodb Positron')
# создаём пустой кластер, добавляем его на карту
marker_cluster = MarkerCluster().add_to(m)

# пишем функцию, которая принимает строку датафрейма,
# создаёт маркер в текущей точке и добавляет его в кластер marker_cluster
def create_clusters(row):
    Marker(
        [row['lon'], row['lat']],
        popup=f"{row['Район']}",
    ).add_to(marker_cluster)

# отфильтуем только районы Москвы
filtered_df = df_total[df_total['Район'].map(lambda x: x in mapping_dict_mo)]
filtered_df = filtered_df.query('Результат != "Отсутствие самостроя"')
# применяем функцию create_clusters() к каждой строке датафрейма
filtered_df.apply(create_clusters, axis=1)

# загружаем JSON-файл с границами округов Москвы
try:
    url = 'https://raw.githubusercontent.com/AVGorbulya/Yandex_Master/main/mos_map.geojson'
    response = requests.get(url)
    data = response.content
    geo_json_data = json.loads(data)  
except Exception as e:
    print("Ошибка при загрузке с удаленного источника:", e)
    state_geo_mo = 'C:\\Users\\GAV\\Desktop\\Study\\BA\\PythonScripts\\Datasets\\mos_map.geojson'
    with open(state_geo_mo, 'r', encoding='utf-8') as file:
        geo_json_data = json.load(file)

    
# создаём хороплет с помощью конструктора Choropleth и добавляем его на карту
Choropleth(
    geo_data=geo_json_data,
    data=city_district_total_share,
    columns=['GeoJSON_Name_mo', 'share_%'],
    key_on='feature.properties.NAME',
    fill_color= 'YlGn',
    fill_opacity=0.5,
    legend_name='Доля проверок, выявивших нарушения по районам г.Москвы',
).add_to(m)

# выводим карту
#m
folium_static(m) 


# Посмотрим на районы, где доля выявляемых нарушений наиболее высокая

# In[ ]:


st.write("""Районы, в которых 100% доля проверок с выявлением нарушений. 
""")


# In[64]:


city_district_total_share_15 = city_district_total_share[(
    city_district_total_share['Количество проверок'] >= 15) & (city_district_total_share['share_%'] == 100)]

city_district_total_share_15.sort_values(
    by=['share_%','Количество проверок'], ascending=False, inplace=True)
city_district_total_share_15.drop(columns={'GeoJSON_Name_mo'}, inplace=True)
city_district_total_share_15.rename(
    columns={'share_%': 'Доля,%'}, inplace=True)
city_district_total_share_15.reset_index(inplace=True)
city_district_total_share_15.drop(columns={'index'}, inplace=True)
city_district_total_share_15


# Вывод:
#         
#         В 13 районах в 100% случаях при проверке были выявлены нарушения. 
#         

# Посмотрим на районы, где доля выявляемых нарушений наименее высокая.

# In[ ]:


st.write("""Районы, в которых наименьшая доля проверок с выявлением нарушений. 
""")


# In[65]:


city_district_total_share_15 = city_district_total_share[(
    city_district_total_share['Количество проверок'] >= 15) & (city_district_total_share['share_%'] < 80)]

city_district_total_share_15.sort_values(
    by='share_%', ascending=True, inplace=True)
city_district_total_share_15.drop(columns={'GeoJSON_Name_mo'}, inplace=True)
city_district_total_share_15.rename(
    columns={'share_%': 'Доля,%'}, inplace=True)
city_district_total_share_15.reset_index(inplace=True)
city_district_total_share_15.drop(columns={'index'}, inplace=True)
city_district_total_share_15


# Вывод: 
#        
#        Районы (с количеством проверок более 15), где от 22% до 43% проверок не выявили нарушений:
#         
#         - Капотня	
#         - Сокольники	
#         - Щукино
#         - Фили-Давыдково
#         - Южное Бутово.      

# #### Анализ количества проверок в разрезе источников задач

# In[66]:


# Подсчитываем общее количество проверок в каждом округе Москвы
tasks_total_counts = df_total.query('Район != "Истринский"').groupby(['Округ'])['№ проверки'].count(
).reset_index(name='total_counts').sort_values(by='total_counts', ascending=False)
print(tasks_total_counts)
print('Всего проверок самостроя', tasks_total_counts['total_counts'].sum())


# In[67]:


# расчет структуры источников проверок по округам
# Группируем данные по районам и категориям, подсчитываем количество проверок
district_tasks_counts = df_total.groupby(['Округ', 'Источник задачи']).size().reset_index(name='counts')

# Объединяем данные с общим количеством проверок
district_tasks_counts = district_tasks_counts.merge(tasks_total_counts[['Округ','total_counts']], on='Округ')

# Вычисляем долю каждой истончика проверок от общего числа заведений в районе
district_tasks_counts['category_share'] = district_tasks_counts['counts'] / district_tasks_counts['total_counts']

# Сортируем данные 
district_tasks_counts = district_tasks_counts.sort_values(by=['Округ'], ascending=[False])

print(district_tasks_counts)


# Построим график распределения мероприятий по округам и источникам задач

# In[ ]:


st.subheader('2.8. Распределение проверок по источникам задач и округам г. Москвы')
st.write("""Выводы:
1. Два основных источника задач во всех округах  - это поручение и обращение ОИВ.
2. В ЦАО также высокую долю занимает камеральная проверка - 10%, а в ЮВАО - инструментальный мониторинг 13%.
""")


# In[68]:


# Установим цветовые схемы
color_templ_4 = dict(zip(df_total.loc[:, ['Источник задачи']]
                      .groupby(by=['Источник задачи'])
                      .sum()
                      .index.to_list(),
                      px.colors.qualitative.Pastel))
# Строим bar chart
fig = px.bar(district_tasks_counts, x='Округ', y='counts', color='Источник задачи', text='category_share',
             title='Распределение проверок по источникам задач и округам г. Москвы',
             labels={'Округ': 'Округ', 'counts': 'Количество проверок, шт.', 'Источник задачи': 'Источник задачи'},
             hover_data={'category_share': ':.1f'},
             color_discrete_sequence=list(color_templ.values()),
             category_orders={'Округ': district_tasks_counts.groupby('Округ')['counts'].sum() \
                                                     .sort_values(ascending=False) \
                                                     .index.to_list()}
            )
             
# Обновляем макет, убираем подложку grid и фон
fig.update_layout(
    xaxis=dict(showgrid=False),
    yaxis=dict(showgrid=False, dtick=150),
    plot_bgcolor='rgba(0,0,0,0)',
    height=700,  
    width=1000   
)
fig.update_traces(texttemplate='%{text:.0%}', textfont_size=12, textangle=0, textposition="inside")

# Отображаем график
#fig.show()
st.plotly_chart(fig) 


# Вывод:
#         
#         1. Два основных источника задач во всех округах  - это поручение и обращение ОИВ.
#         2. В ЦАО также высокую долю занимает камеральная проверка - 10%, а в ЮВАО Инструментальный мониторинг 13%.

# #### Анализ количества проверок в разрезе их типов

# In[69]:


# расчет структуры источников проверок по округам
# Группируем данные по районам и категориям, подсчитываем количество проверок
district_events_counts = df_total.groupby(['Округ', 'Вид мероприятия']).size().reset_index(name='counts')

# Объединяем данные с общим количеством проверок
district_events_counts = district_events_counts.merge(tasks_total_counts[['Округ','total_counts']], on='Округ')

# Вычисляем долю каждой истончика проверок от общего числа в районе
district_events_counts['category_share'] = district_events_counts['counts'] / district_events_counts['total_counts']

# Сортируем данные 
district_events_counts = district_events_counts.sort_values(by=['Округ'], ascending=[False])

print(district_events_counts.head())


# In[ ]:


st.subheader('2.9. Распределение проверок по видам мероприятий и округам г. Москвы')
st.write("""Выводы:
1. От 77 до 94% всех проверок во всех округах относятся к выездным мероприятиям.
""")


# In[70]:


# Строим bar chart
fig = px.bar(district_events_counts, x='Округ', y='counts', color='Вид мероприятия', text='category_share',
             title='Распределение проверок по видам мероприятий и округам г. Москвы',
             labels={'Округ': 'Округ', 'counts': 'Количество проверок, шт.', 'Вид мероприятия': 'Вид мероприятия'},
             hover_data={'category_share': ':.1f'},
             color_discrete_sequence=list(color_templ.values()),
             category_orders={'Округ': district_events_counts.groupby('Округ')['counts'].sum() \
                                                     .sort_values(ascending=False) \
                                                     .index.to_list()}
            )
             
# Обновляем макет, убираем подложку grid и фон
fig.update_layout(
    xaxis=dict(showgrid=False),
    yaxis=dict(showgrid=False, dtick=150),
    plot_bgcolor='rgba(0,0,0,0)',
    height=700,  
    width=1000   
)
fig.update_traces(texttemplate='%{text:.0%}', textfont_size=12, textangle=0, textposition="inside")

# Отображаем график
#fig.show()
st.plotly_chart(fig) 


# Вывод:
#        
#        От 77 до 94% всех проверок во всех округах относятся к выездным мероприятиям.
#        

# #### Анализ видов нарушений, выявленных проверками

# In[71]:


# расчет структуры видов нарушений по округам
# Группируем данные по районам и видам, подсчитываем количество проверок
district_result_counts = df_total.groupby(['Округ', 'Результат']).size().reset_index(name='counts')

# Объединяем данные с общим количеством проверок
district_result_counts = district_result_counts.merge(tasks_total_counts[['Округ','total_counts']], on='Округ')

# Вычисляем долю каждой истончика проверок от общего числа в районе
district_result_counts['category_share'] = district_result_counts['counts'] / district_result_counts['total_counts']

# Сортируем данные 
district_result_counts = district_result_counts.sort_values(by=['Округ'], ascending=[False])

print(district_result_counts.head())


# In[ ]:


st.subheader('2.10. Анализ видов нарушений, выявленных в рамках проверок')
st.write("""Выводы:
1. Два основных вида нарушений - нецелевое использование земли и незаконное размещение объекта.
2. При этом в ЦАО чаще выявляют самострой, в остальных округах, наоборот нецелевое использование земли.
""")


# In[72]:


# Строим bar chart
fig = px.bar(district_result_counts, x='Округ', y='counts', color='Результат', text='category_share',
             title='Анализ видов нарушений, выявленных в рамках проверок',
             labels={'Округ': 'Округ', 'counts': 'Количество проверок, шт.', 'Результат': 'Результат'},
             hover_data={'category_share': ':.1f'},
             color_discrete_sequence=list(color_templ.values()),
             category_orders={'Округ': district_result_counts.groupby('Округ')['counts'].sum() \
                                                     .sort_values(ascending=False) \
                                                     .index.to_list()}
            )
             
# Обновляем макет, убираем подложку grid и фон
fig.update_layout(
    xaxis=dict(showgrid=False),
    yaxis=dict(showgrid=False, dtick=150),
    plot_bgcolor='rgba(0,0,0,0)',
    height=700,  
    width=1000   
)
fig.update_traces(texttemplate='%{text:.0%}', textfont_size=12, textangle=0, textposition="inside")

# Отображаем график
#fig.show()
st.plotly_chart(fig) 


# Вывод:
#         
#         1. Два основных вида нарушений - нецелевое использование земли и незаконное размещение объекта
#         2. При этом в ЦАО чаще выявляют самострой, в остальных округах, наоборот нецелевое использование земли.

# ### Итоговые выводы и рекомендации

# #### Результаты анализа данных
# 
# Проанализированы данные о результатах проверок за период с 01.2023 по 03.2024 г.
#    
#        1. Анализ количества выявленных незаконных объектов показал:
#     
#             1.1 Всего выявлено 2726 объектов с нарушениями.
#             1.2. Лидеры по количеству объектов ЦАО, ЮВАО и ВАО, СВАО. В этих районах находятся около 60% всех объектов самостроя.
#             1.3. Меньше всего в ЮЗАО - 1,5% и на территориях "новой Москвы" (НАО, ТАО).
#        
#        2. Анализ типов выявленных объектов показал: 
#            2.1 Существенное количество объектов от 20% до 64% в большинстве классифицировано как прочее. Необходимо разработать подход к унификации справочника типов объектов, так как сейчас помимо существенной доли  неопределенного типа объектов, есть и неявные дубли в классификации (например, ГСК и гараж, строение и отдельное строение).
#            2.2. В лидерах по типам объектов самостроя: пристройка, строение, надстройка, здание.
#            2.3  В ЦАО также выделяются мансарды с долей 6%.
#            
#       3. Анализ характеристик объектов самостроя по площади: самые крупные по площади надстройки и мансарды ( с медианой 730 и 650 кв. м.);
#       
#       4.Анализ количества проверок по объектам, показал что в основном за представленный период с января 2023 по март 2024 97% выявленных объектов проверены 1 раз, 2.99% - проверены дважды.
#       5. Анализ частота проведения проверок и количества выявленных нарушений по округам показал:
#           5.1 в среднем проводлось 209 проверок в месяц (медиана).
#           5.2. Больше всего проверок было проведено в марте, апреле, октябре 2023 и феврале 2024 г.
#           5.3. В среднем в 92% случаях проверки выявляют нарушения.
#       
#       6. Анализ количества проверок по районам показал:
#           6.1  Лидеры по числу проверок Басманный район и Печатники, следом идут Таганский и Соколиная Гора.
#           6.2. Нет информации о проверках в районах Теплый стан и Котловка. Либо их не проверяли весь год, либо представленная база не полная.
#       
#       7. Анализ количества выявленных нарушений по районам показал:
#       
#           7.1 В среднем за год в районах выявляют около 13 нарушений, при этом в 15 районах за год выявлено от 1 до 3 нарушений, в 15 районах за год выявлено от  37 до 178 нарушений.
#           7.2  Лидеры по числу нарушений Басманный район и Печатники.
#           7.3 Фактически данные о количестве нарушений повторяют информацию о количестве проверок, то есть, где больше проверяют, там выявляют больше нарушений.
#           7.4 В 13 районах в 100% случаях при проверке были выявлены нарушения.
#           
#           7.5 Районы (с количеством проверок более 15), где от 22% до 43% проверок не выявили нарушений:
# 
#                 - Капотня    
#                 - Сокольники    
#                 - Щукино
#                 - Фили-Давыдково
#                 - Южное Бутово. 
#       
#       8. Анализ количества проверок в разрезе источников задач показал:
#           8.1. Два основных источника задач во всех округах  - это поручение и обращение ОИВ.
#           8.2. В ЦАО также высокую долю занимает камеральная проверка - 10%, а в ЮВАО Инструментальный мониторинг 13%.
#       9. Анализ количества проверок в разрезе их типов показал, что от 77 до 94% всех проверок во всех округах  относятся к выездным мероприятиям.
#       
#       10. Анализ видов нарушений, выявленных проверками показал:
#       
#           10.1. Два основных вида нарушений - нецелевое использование земли и незаконное размещение объекта
#           10.2. В ЦАО чаще выявляют самострой, в остальных округах, наоборот нецелевое использование земли.

# #### Рекомендации  части обеспечения качества и непротиворечивости данных
#     
#         1.1 Необходимо унифицировать справочники типов объектов, источников задач, видов нарушений и др;
#         1.2 Исключить ручной ввод дублирующей информации, если она есть в одной из таблиц она должна подтягиваться автоматически.
#         1.3 Исключить ввод дублирующих мероприятий (если совпдает объект, дата, время, источник и т.д)
#         1.4 Удалить неиспользуемые поля (полностью пустые)
#         1.5 Организовать процедуру проверки полноты базы, так как по 2-м районам (Теплый стан, Котловка ) полностью отсутствует информация, но присутствуют данные по району (Истринский), который не относится к Москве.

# In[119]:


st.subheader('Рекомендации в части обеспечения качества и непротиворечивости данных')
st.write("""
1. Необходимо унифицировать справочники типов объектов, источников задач, видов нарушений и др.
2. Исключить ручной ввод дублирующей информации, если она есть в одной из таблиц она должна подтягиваться автоматически.
3. Исключить ввод дублирующих мероприятий (если совпдает объект, дата, время, источник и т.д)
4. Удалить неиспользуемые поля (полностью пустые)
5. Организовать процедуру проверки полноты базы, так как по 2-м районам (Теплый стан, Котловка ) полностью отсутствует информация, но присутствуют данные по району (Истринский), который не относится к Москве.
""")

